(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{253:function(_,t,s){"use strict";s.r(t);var i=s(0),v=Object(i.a)({},(function(){var _=this,t=_.$createElement,s=_._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h2",{attrs:{id:"elasticsearch-dsl查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch-dsl查询"}},[_._v("#")]),_._v(" ElasticSearch - DSL查询")]),_._v(" "),s("blockquote",[s("p",[_._v("总结ES应用场景")])]),_._v(" "),s("h3",{attrs:{id:"基本查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本查询"}},[_._v("#")]),_._v(" 基本查询")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("词条查询。仅匹配在给定字段中含有该词条的文档，而且是确切的、未经分析的词条。")])]),_._v(" "),s("li",[s("p",[_._v("多词条查询。匹配那些在内容中含有某些词条的文档。可以通过设置minimum_match的值来说明想至少保证有多少个词同时被匹配上。")])]),_._v(" "),s("li",[s("p",[_._v("match_all查询。匹配索引中的所有的文件。")])]),_._v(" "),s("li",[s("p",[_._v("常用词查询。考虑到查询条件的词越多，查询性能越低。所以将词分为两类：一类，是重要的词，出现的频率较低；另一类，是出现频率较高，如：”的”，但不那么重要的词。")])]),_._v(" "),s("li",[s("p",[_._v("match查询")])]),_._v(" "),s("li",[s("p",[_._v("multi_match查询。基本与match一样，不同的是它不是针对单个字段，而是针对多个字段执行相同的 match 查询。")])]),_._v(" "),s("li",[s("p",[_._v("match_phrase。精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且二者以短语 “rock climbing” 的形式紧挨着的雇员记录。")])]),_._v(" "),s("li",[s("p",[_._v("query_string查询")])]),_._v(" "),s("li",[s("p",[_._v("simple_query_string查询")])]),_._v(" "),s("li",[s("p",[_._v("标识符查询")])]),_._v(" "),s("li",[s("p",[_._v("前缀查询。配置与词条查询类似。如：查询所有的name字段以tom开始的文档。")])]),_._v(" "),s("li",[s("p",[_._v("fuzzy_like_this查询")])]),_._v(" "),s("li",[s("p",[_._v("fuzzy_like_this_field查询")])]),_._v(" "),s("li",[s("p",[_._v("fuzzy查询")])]),_._v(" "),s("li",[s("p",[_._v("通配符查询。允许我们在查询值中使用*和？等通配符。如“cr*me”，表示字段里以cr开头me结尾的文档。")])]),_._v(" "),s("li",[s("p",[_._v("more_like_this查询")])]),_._v(" "),s("li",[s("p",[_._v("more_like_this_field查询")])]),_._v(" "),s("li",[s("p",[_._v("range 范围查询")]),_._v(" "),s("p",[_._v("查询某一个字段值在某一个范围里的文档，字段可以是数值型，也可以是基于字符串的。比如找到年龄在20到30之间的学生。")])]),_._v(" "),s("li",[s("p",[_._v("最大分查询")])]),_._v(" "),s("li",[s("p",[_._v("正则表达式查询")])]),_._v(" "),s("li",[s("p",[_._v("term 查询。")]),_._v(" "),s("p",[_._v("查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串。而无需对查询结果进行评分计算。")])]),_._v(" "),s("li",[s("p",[_._v("exists 查询和 missing 查询。")]),_._v(" "),s("p",[_._v("用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上是相同的。")])])]),_._v(" "),s("h3",{attrs:{id:"复合查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复合查询"}},[_._v("#")]),_._v(" 复合查询")]),_._v(" "),s("ul",[s("li",[_._v("布尔查询")])]),_._v(" "),s("p",[_._v("在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤，将多查询组合成单一查询。可以用 bool 查询来实现你的需求。")]),_._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("must 文档 必须 匹配这些条件才能被包含进来。\nmust_not 文档 必须不 匹配这些条件才能被包含进来。\nshould 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。\nfilter 必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br")])]),s("ul",[s("li",[_._v("加权查询")]),_._v(" "),s("li",[_._v("constant_score查询")]),_._v(" "),s("li",[_._v("索引查询")])]),_._v(" "),s("h3",{attrs:{id:"过滤器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过滤器"}},[_._v("#")]),_._v(" 过滤器")]),_._v(" "),s("p",[_._v("filter 过滤器不影响评分，只是选择索引中的某个子集。过滤器很容易被缓存，从而进一步提高过滤查询的性能。另外过滤器提供了十几种不同类型，如：范围过滤器、脚本过滤器等等，可以根据不同场景选择合适的。")]),_._v(" "),s("h3",{attrs:{id:"深入搜索"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深入搜索"}},[_._v("#")]),_._v(" 深入搜索")]),_._v(" "),s("p",[_._v("https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html\n里面提供了多维度、更灵活的搜索场景以及案例。")]),_._v(" "),s("h3",{attrs:{id:"排序与相关性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序与相关性"}},[_._v("#")]),_._v(" 排序与相关性")]),_._v(" "),s("p",[_._v("相关性得分由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("按单个字段的值排序")])]),_._v(" "),s("li",[s("p",[_._v("多级排序")]),_._v(" "),s("p",[_._v("比如我们想要结合使用 date 和 _score 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序。https://www.elastic.co/guide/cn/elasticsearch/guide/current/_Sorting.html\n。多级排序并不一定包含 _score 。你可以根据一些不同的字段进行排序， 如地理距离或是脚本计算的特定值。")])])]),_._v(" "),s("h3",{attrs:{id:"基于poi经纬度地理位置的查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于poi经纬度地理位置的查询"}},[_._v("#")]),_._v(" 基于poi经纬度地理位置的查询")]),_._v(" "),s("ul",[s("li",[_._v("基于距离的排序。按照与给定地点的距离来对结果排序。")]),_._v(" "),s("li",[_._v("边界框过滤。搜索条件提供左上及右下的坐标，搜索被矩形框住的选定区域。")]),_._v(" "),s("li",[_._v("距离的限制。把结果限定为离基准点一个选定的距离之内，比如把结果限定为离巴黎半径500公里以内。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);